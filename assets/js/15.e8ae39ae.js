(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{338:function(e,t,r){"use strict";r.r(t);var a=r(33),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("baseHandlers 中主要包含四种 handler, mutableHandlers、readonlyHandlers、shallowReactiveHandlers、 shallowReadonlyHandlers。 这里先介绍 mutableHandlers， 因为其他三种 handler 也算是 mutableHandlers 的变形版本。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n")])])]),r("p",[e._v("从 mdn 上面可以看到，")]),e._v(" "),r("ol",[r("li",[e._v("handler.get() 方法用于拦截对象的读取属性操作。")]),e._v(" "),r("li",[e._v("handler.set() 方法是设置属性值操作的捕获器。")]),e._v(" "),r("li",[e._v("handler.deleteProperty() 方法用于拦截对对象属性的 delete 操作。")]),e._v(" "),r("li",[e._v("handler.has() 方法是针对 in 操作符的代理方法。")]),e._v(" "),r("li",[e._v("handler.ownKeys() 方法用于拦截\n"),r("ul",[r("li",[e._v("Object.getOwnPropertyNames()")]),e._v(" "),r("li",[e._v("Object.getOwnPropertySymbols()")]),e._v(" "),r("li",[e._v("Object.keys()")]),e._v(" "),r("li",[e._v("for…in循环")])])])]),e._v(" "),r("p",[e._v("从下面可以看到 ownKeys 触发时，主要追踪 ITERATE 操作，has 触发时，追踪 HAS 操作，而 deleteProperty 触发时，我们要看看是否删除成功以及删除的 key 是否是对象自身拥有的。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  track(target, TrackOpTypes.HAS, key)\n  return result\n}\n\nfunction ownKeys(target: object): (string | number | symbol)[] {\n  track(target, TrackOpTypes.ITERATE, ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n")])])]),r("p",[e._v("接下来看看 set handler, set 函数通过 createSetter 工厂方法 进行创建，/"),r("em",[e._v("#"),r("strong",[e._v("PURE")])]),e._v("/ 是为了 rollup tree shaking 的操作。")]),e._v(" "),r("p",[e._v("对于非 shallow , 如果原来的对象不是数组， 旧值是 ref，新值不是 ref，则让新的值 赋值给 ref.value , 让 ref 去决定 trigger，这里不展开，ref 会在ref 章节展开。\n如果是 shallow ，管它三七二十一呢。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const set = /*#__PURE__*/ createSetter()\nconst shallowSet = /*#__PURE__*/ createSetter(true)\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    const oldValue = (target as any)[key]\n    if (!shallow) {\n      value = toRaw(value)\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n\n   ...\n    return result\n  }\n}\n")])])]),r("p",[e._v("接下来进行设置，需要注意的是，如果 target 是在原型链的值，那么  Reflect.set(target, key, value, receiver) 的设值值设置起作用的是 receiver 而不是 target，这也是什么在这种情况下不要触发 trigger 的原因。")]),e._v(" "),r("p",[e._v("那么在 target === toRaw(receiver) 时，如果原来 target 上面有 key， 则触发 SET 操作，否则触发 ADD 操作。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    const hadKey = hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n")])])]),r("p",[e._v("接下来说说 get 操作，get 有四种，我们先拿其中一种说说。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const get = /*#__PURE__*/ createGetter()\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: object, key: string | symbol, receiver: object) {\n    ...\n\n    \n    const res = Reflect.get(target, key, receiver)\n\n    if (isSymbol(key) && builtInSymbols.has(key) || key === '__proto__') {\n      return res\n    }\n\n    if (shallow) {\n      !isReadonly && track(target, TrackOpTypes.GET, key)\n      return res\n    }\n\n    if (isRef(res)) {\n      if (targetIsArray) {\n        !isReadonly && track(target, TrackOpTypes.GET, key)\n        return res\n      } else {\n        // ref unwrapping, only for Objects, not for Arrays.\n        return res.value\n      }\n    }\n\n    !isReadonly && track(target, TrackOpTypes.GET, key)\n    return isObject(res)\n      ? isReadonly\n        ? // need to lazy access readonly and reactive here to avoid\n          // circular dependency\n          readonly(res)\n        : reactive(res)\n      : res\n  }\n}\n")])])]),r("p",[e._v("首先如果 key 是 ReactiveFlags， 直接返回值，ReactiveFlags 的枚举值在 reactive 中讲过。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" if (key === ReactiveFlags.isReactive) {\n  return !isReadonly\n} else if (key === ReactiveFlags.isReadonly) {\n  return isReadonly\n} else if (key === ReactiveFlags.raw) {\n  return target\n}\n")])])]),r("p",[e._v("而如果 target 是数组，而且调用了 ['includes', 'indexOf', 'lastIndexOf'] 这三个方法，则调用 arrayInstrumentations 进行获取值，")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const targetIsArray = isArray(target)\n    if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n")])])]),r("p",[e._v("arrayInstrumentations 中会触发数组每一项值得 GET 追踪，因为 一旦数组的变了，方法的返回值也会变，所以需要全部追踪。对于 args 参数，如果第一次调用返回失败，会尝试将 args 进行 toRaw 再调用一次。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const arrayInstrumentations: Record<string, Function> = {}\n;['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n  arrayInstrumentations[key] = function(...args: any[]): any {\n    const arr = toRaw(this) as any\n    for (let i = 0, l = (this as any).length; i < l; i++) {\n      track(arr, TrackOpTypes.GET, i + '')\n    }\n    // we run the method using the original args first (which may be reactive)\n    const res = arr[key](...args)\n    if (res === -1 || res === false) {\n      // if that didn't work, run it again using raw values.\n      return arr[key](...args.map(toRaw))\n    } else {\n      return res\n    }\n  }\n})\n")])])]),r("p",[e._v("如果 key 是 Symbol ，而且也是 ecma 中 Symbol 内置的 key 或者 key 是 获取对象上面的原型，则直接返回 res 值。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const res = Reflect.get(target, key, receiver)\n\nif (isSymbol(key) && builtInSymbols.has(key) || key === '__proto__') {\n  return res\n}\n")])])]),r("p",[e._v("而如果是 shallow 为 true，说明而且不是只读的，则追踪 GET 追踪，这里可以看出，只读不会进行追踪。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (shallow) {\n  !isReadonly && track(target, TrackOpTypes.GET, key)\n  return res\n}\n\n")])])]),r("p",[e._v("接下来都是针对非 shallow的。\n如果返回值是 ref，且 target 是数组，在非可读的情况下，进行 Get 的 Track 操作，对于如果 target 是对象，则直接返回 ref.value，但是不会在这里触发 Get 操作，而是由 ref 内部进行 track。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (isRef(res)) {\n  if (targetIsArray) {\n    !isReadonly && track(target, TrackOpTypes.GET, key)\n    return res\n  } else {\n    // ref unwrapping, only for Objects, not for Arrays.\n    return res.value\n  }\n}\n")])])]),r("p",[e._v("对于非只读，我们还要根据 key 进行 Track。而对于返回值，如果是对象，我们还要进行一层 wrap, 但这层是 lazy 的，也就是只有我们读取到 key 的时候，才会读下面的 值进行 reactive 包装，这样可以避免出现循环依赖而导致的错误，因为这样就算里面有循环依赖也不怕，反正是延迟取值，而不会导致栈溢出。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("!isReadonly && track(target, TrackOpTypes.GET, key)\nreturn isObject(res)\n  ? isReadonly\n    ? // need to lazy access readonly and reactive here to avoid\n      // circular dependency\n      readonly(res)\n    : reactive(res)\n  : res\n")])])]),r("p",[e._v("这就是 mutableHandlers ，而对于 readonlyHandlers，我们可以看出首先不允许任何 set、 deleteProperty 操作，然后对于 get，我们刚才也知道，不会进行 track 操作。剩下两个 shallowGet 和 shallowReadonlyGet，就不在讲了。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('export const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  has,\n  ownKeys,\n  set(target, key) {\n    if (__DEV__) {\n      console.warn(\n        `Set operation on key "${String(key)}" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    if (__DEV__) {\n      console.warn(\n        `Delete operation on key "${String(key)}" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  }\n}\n\n')])])])])}),[],!1,null,null,null);t.default=n.exports}}]);