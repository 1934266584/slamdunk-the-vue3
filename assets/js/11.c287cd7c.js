(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{325:function(e,n,r){"use strict";r.r(n);var o=r(33),s=Object(o.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("compiler 主要用于编译模板生成渲染函数，期间一共经历三个过程，分别是 parse、transform 和 codegen。parse 是初步将我们的模板转化成 ast，transform 是对我们生成的 ast 进行转化，包括了 nodeTransform 和 directiveTransform， 最后是 codegen， 将转化后的 ast 生成 字符串代码。")]),e._v(" "),r("p",[e._v("接下来，会将 compiler-dom 和 compiler-core 串烧起来，一起康康 compiler 到底做了什么。")]),e._v(" "),r("p",[e._v("下面是 compiler-dom 的 compile 方法，baseCompile 是 compiler-core 暴露出来的，方便不同平台传入自己的 option，这里是 dom 平台，parserOptions 就是 dom 平台传入的针对 dom 的 option ，同时也传入了平台 nodeTransforms 的  DOMNodeTransforms 和 directiveTransforms 的 DOMDirectiveTransforms。 transformHoist 代表要不要对 hoist 进行转化， 注意这个只在 node 平台进行转化，在 compiler 会经常 看到 "),r("code",[e._v("__BROWSER__")]),e._v("的判断，这是因为有些优化只能在 node 进行，对于浏览器运行时进行编译是没办法做到的。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(template, {\n    ...parserOptions,\n    ...options,\n    nodeTransforms: [...DOMNodeTransforms, ...(options.nodeTransforms || [])],\n    directiveTransforms: {\n      ...DOMDirectiveTransforms,\n      ...(options.directiveTransforms || {})\n    },\n    transformHoist: __BROWSER__ ? null : stringifyStatic\n  })\n}\n")])])]),r("p",[e._v("那接下来先看看 parserOptions。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export const parserOptions: ParserOptions = {\n  isVoidTag,\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n  isPreTag: tag => tag === 'pre',\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\n\n  isBuiltInComponent: (tag: string): symbol | undefined => {\n    if (isBuiltInType(tag, `Transition`)) {\n      return TRANSITION\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP\n    }\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\n    ...\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode({ tag, ns }: ElementNode): TextModes {\n    ...\n  }\n}\n")])])]),r("p",[e._v("isVoidTag 表示标签是不是自闭和标签，isNativeTag 表示是不是平台的原生标签， isPreTag 表示标签是不是 pre 标签，decodeEntities 对内容进行解码，isBuiltInComponent 表示是不是内部自带的标签，getNamespace 获取 标签的 namespace，这个会影响 parse 解析，getTextMode 获取标签的 TextMode，不同 TextMode 也会影响 parse 解析，这些在后面讲 parse 会进行细讲。")]),e._v(" "),r("p",[e._v("接下来看看 baseComplie, 从下面也可以看出，编译的过程就是上面说的三大斧，parse、 transform 和 generate 。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  ...\n  const ast = isString(template) ? baseParse(template, options) : template\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(\n    prefixIdentifiers\n  )\n  transform(ast, {\n    ...options,\n    prefixIdentifiers,\n    nodeTransforms: [\n      ...nodeTransforms,\n      ...(options.nodeTransforms || []) // user transforms\n    ],\n    directiveTransforms: {\n      ...directiveTransforms,\n      ...(options.directiveTransforms || {}) // user transforms\n    }\n  })\n\n  return generate(ast, {\n    ...options,\n    prefixIdentifiers\n  })\n}\n\n")])])]),r("p",[e._v("当然在深入讲解具体每个过程之前，先看看 baseCompile 中对参数的校验。对于 Dom compiler , 不支持前缀，就是生成的代码用 with 包住 ctx，因为添加前缀操作需要 操作 js ast， 同样 Dom Complier 也不支持 module 模式。")]),e._v(" "),r("p",[e._v("而对于 node 编译时， 如果不指定前缀，又想缓存 v-on 的 handler 也是不可以，因为 "),r("code",[e._v("{ onClick: _cache[0] || (_cache[0] = e => _ctx.foo(e)) }")]),e._v("，懂了吧。")]),e._v(" "),r("p",[e._v("最后，如果指定了 scopeId ，但又不是 module 模式，那也是不可以的，常见的 module 模式就是 sfc 。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(" const onError = options.onError || defaultOnError\n  const isModuleMode = options.mode === 'module'\n  /* istanbul ignore if */\n  if (__BROWSER__) {\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\n    } else if (isModuleMode) {\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\n    }\n  }\n\n  const prefixIdentifiers =\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\n  if (!prefixIdentifiers && options.cacheHandlers) {\n    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))\n  }\n  if (options.scopeId && !isModuleMode) {\n    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))\n  }\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);