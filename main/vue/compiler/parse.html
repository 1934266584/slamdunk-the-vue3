<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue3.0 源码解读</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/slamdunk-the-vue3/onepunch.jpeg">
    <script src="https://hm.baidu.com/hm.js?4484bd6412288feacc311fd7f2054116"></script>
    <meta name="description" content="Vue3.0 源码解读">
    <link rel="preload" href="/slamdunk-the-vue3/assets/css/0.styles.bc380d03.css" as="style"><link rel="preload" href="/slamdunk-the-vue3/assets/js/app.97c78449.js" as="script"><link rel="preload" href="/slamdunk-the-vue3/assets/js/2.ff58ff2a.js" as="script"><link rel="preload" href="/slamdunk-the-vue3/assets/js/12.65c8523a.js" as="script"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/10.7120d09e.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/11.edae011a.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/13.6d57198b.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/14.6f17459f.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/15.d661946e.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/16.1d75929f.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/17.c14dbecb.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/18.ead9747b.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/19.6890f1ff.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/20.8d152f5d.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/21.925c91fa.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/22.1d209a45.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/3.5ca37265.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/4.fca74266.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/5.98f771c6.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/6.d22c36dd.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/7.14cdc3d0.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/8.bb7f35ab.js"><link rel="prefetch" href="/slamdunk-the-vue3/assets/js/9.0e8c094d.js">
    <link rel="stylesheet" href="/slamdunk-the-vue3/assets/css/0.styles.bc380d03.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/slamdunk-the-vue3/" class="home-link router-link-active"><!----> <span class="site-name">Vue3.0 源码解读</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/slamdunk-the-vue3/main/" class="nav-link router-link-active">
  Vue 3.0 解读
</a></div><div class="nav-item"><a href="/slamdunk-the-vue3/about.html" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/hkc452/slamdunk-the-vue3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/slamdunk-the-vue3/main/" class="nav-link router-link-active">
  Vue 3.0 解读
</a></div><div class="nav-item"><a href="/slamdunk-the-vue3/about.html" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/hkc452/slamdunk-the-vue3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>响应式系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/slamdunk-the-vue3/main/vue/reactivity/effect.html" class="sidebar-link">effect</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/reactive.html" class="sidebar-link">reactive</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/baseHandlers.html" class="sidebar-link">baseHandlers</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/collectionHandlers.html" class="sidebar-link">collectionHandlers</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/ref.html" class="sidebar-link">ref</a></li><li><a href="/slamdunk-the-vue3/main/vue/reactivity/computed.html" class="sidebar-link">computed</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>编译模块</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/slamdunk-the-vue3/main/vue/compiler/compiler.html" class="sidebar-link">compiler</a></li><li><a href="/slamdunk-the-vue3/main/vue/compiler/parse.html" class="active sidebar-link">parse</a></li><li><a href="/slamdunk-the-vue3/main/vue/compiler/transform.html" class="sidebar-link">transform</a></li><li><a href="/slamdunk-the-vue3/main/vue/compiler/codegen.html" class="sidebar-link">codegen</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>这里主要讲讲 parse ，看看 Vue 怎么对模板进行初步的解析。 在 compile 中调用 baseParse 进行 parse，所以这里先看看 baseParse 。</p> <p>在解析之前，会创建一个上下文，用于保存当前解析进度和一些配置项。</p> <div class="language- extra-class"><pre class="language-text"><code>export function baseParse(
  content: string,
  options: ParserOptions = {}
): RootNode {
  const context = createParserContext(content, options)
  const start = getCursor(context)
  return createRoot(
    parseChildren(context, TextModes.DATA, []),
    getSelection(context, start)
  )
}
</code></pre></div><p>options 中基本是用 parseOptions 传下来的 options 进行覆盖， column 表示第几行， line 表示第几列， offset 表示传入 content 的偏差，originalSource 表示原始字符串，在 parse 不会被修改，source 一开始代表原始字符串，在 parse 过程会被裁剪， inPre 表示是否在 pre 标签里面，inVPre 表示是否在 VPre 标签里面。</p> <div class="language- extra-class"><pre class="language-text"><code>function createParserContext(
  content: string,
  options: ParserOptions
): ParserContext {
  return {
    options: {
      ...defaultParserOptions,
      ...options
    },
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false
  }
}
</code></pre></div><p>回到 baseParse，创建完 context 之后，我们首先获取一开始的字符串的坐标。 getCursor 返回当前的 行、列、偏差。</p> <div class="language- extra-class"><pre class="language-text"><code>function getCursor(context: ParserContext): Position {
  const { column, line, offset } = context
  return { column, line, offset }
}
</code></pre></div><p>然后在调用 createRoot 返回根节点的 ast 之前，使用 parseChildren 对模板进行解析。一开始的 TextModes 为DATA，正如我们在 compiler 里面曾经说过，不同的 TextModes 会影响解析。 从下面可以看出，DATA 可以包含 Elements、 Entities ，结束的标志是在 tags 栈中找到 关闭 tag，而对于 RCDATA，不包含  Elements，包含Entities， 结束的标志是 tags 栈上一级有关闭 tag， 一般处于 textarea，RAWTEXT 不包含  Elements 和Entities，结束的标志页数是 tags 栈上一级有关闭 tag，一般位于 style 和 script 内。可能在这里单独讲概念有点懵，后面结合解析过程来会加深理解。</p> <div class="language- extra-class"><pre class="language-text"><code>export const enum TextModes {
  //          | Elements | Entities | End sign              | Inside of
  DATA, //    | ✔        | ✔        | End tags of ancestors |
  RCDATA, //  | ✘        | ✔        | End tag of the parent | &lt;textarea&gt;
  RAWTEXT, // | ✘        | ✘        | End tag of the parent | &lt;style&gt;,&lt;script&gt;
  CDATA,
  ATTRIBUTE_VALUE
}
parseChildren(context, TextModes.DATA, [])
</code></pre></div><p>需要注意的是，对于 Dom 平台来说，对于 DOMNamespaces.HTML,包括在 iframe 和 noscript 标签里面，RCDATA 还包括 title。</p> <div class="language- extra-class"><pre class="language-text"><code>const isRawTextContainer = /*#__PURE__*/ makeMap(
  'style,iframe,script,noscript',
  true
)
getTextMode({ tag, ns }: ElementNode): TextModes {
    if (ns === DOMNamespaces.HTML) {
      if (tag === 'textarea' || tag === 'title') {
        return TextModes.RCDATA
      }
      if (isRawTextContainer(tag)) {
        return TextModes.RAWTEXT
      }
    }
    return TextModes.DATA
}
</code></pre></div><p>现在进行 parseChildren 的分析。首先获取父级 以及 父级的Namespaces，nodes 是解析后的 AST 节点。可以看到，一个 while 循环判断是否解析结束了，同时会 传入去 mode、ancestors，对于根节点来说，ancestors 一开始为空数组。</p> <div class="language- extra-class"><pre class="language-text"><code>function parseChildren(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[]
): TemplateChildNode[] {
  const parent = last(ancestors)
  const ns = parent ? parent.ns : Namespaces.HTML
  const nodes: TemplateChildNode[] = []

  while (!isEnd(context, mode, ancestors)) {
    ...
  }

  // Whitespace management for more efficient output
  // (same as v2 whitespace: 'condense')
  let removedWhitespace = false
  if (mode !== TextModes.RAWTEXT) {
    ...
  }

  return removedWhitespace ? nodes.filter(Boolean) : nodes
}
</code></pre></div><p>isEnd 用于判断是否应该要结束解析，但是不同 TextMode 下，对 end 的判断是不同的，其实这点在上面讲 TextModes 的时候已经讲了，TextModes.DATA 允许有标签没闭合，所以只要祖先有相同的标签就可以了，而 RCDATA、RAWTEXT 要求父级标签跟闭合标签一样才算结束，而对于 TextModes.CDATA ，则要求 <code>]]&gt;</code> 结尾，如果都不符合这些条件，则看看 s 是否为空来决定是否到尽头了。</p> <div class="language- extra-class"><pre class="language-text"><code>function isEnd(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[]
): boolean {
  const s = context.source

  switch (mode) {
    case TextModes.DATA:
      if (startsWith(s, '&lt;/')) {
        //TODO: probably bad performance
        for (let i = ancestors.length - 1; i &gt;= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true
          }
        }
      }
      break

    case TextModes.RCDATA:
    case TextModes.RAWTEXT: {
      const parent = last(ancestors)
      if (parent &amp;&amp; startsWithEndTagOpen(s, parent.tag)) {
        return true
      }
      break
    }

    case TextModes.CDATA:
      if (startsWith(s, ']]&gt;')) {
        return true
      }
      break
  }

  return !s
}
</code></pre></div><p>回到 while 循环，如果 isEnd 为 false， 进入循环，如果 mode 为 <code>mode === TextModes.DATA || mode === TextModes.RCDATA</code> 则进入 if 里面，否者往下走，如果这时 node 还为空，则直接进行 parseText 操作。</p> <div class="language- extra-class"><pre class="language-text"><code>__TEST__ &amp;&amp; assert(context.source.length &gt; 0)
const s = context.source
let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined
if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
    ...
}
if (!node) {
  node = parseText(context, mode)
}
</code></pre></div><p>parseText, 看名字就知道用来干嘛的，首先利用 endTokens 去判断结尾，分别是标签的开头、左delimiters， 如果是 TextModes.CDATA 模式下，还包括 <code>]]&gt;</code>， 我们需要最小的 endIndex，即尽可能短的 Text，接着使用 parseTextData 对内容解析。</p> <p>parseTextData 首先 slice source 得到 rawtext，然后 advanceBy 让 context 中 columin、 line 往前进同时对 context.source 进行切割。接下来的判断，就是决定要不要对 Entities 进行解码，对于 <code>mode === TextModes.RAWTEXT || mode === TextModes.CDATA</code> 这两种不需要解码，而如果是其他模式，但是里面没有 <code>&amp;</code>， 也不需要解码，否则调用传进来的解码函数进行解码。</p> <p>parseTextData 结束后，返回 AST 节点，其中类型为 NodeTypes.TEXT， 内容为 parseTextData 返回的内容，loc 代表这个节点开始位置、结束位置以及原始内容，其中位置用三个维度去表示 行、列、偏移，需要记住的是，结束位置是开区间。</p> <div class="language- extra-class"><pre class="language-text"><code>function parseText(context: ParserContext, mode: TextModes): TextNode {
  __TEST__ &amp;&amp; assert(context.source.length &gt; 0)

  const endTokens = ['&lt;', context.options.delimiters[0]]
  if (mode === TextModes.CDATA) {
    endTokens.push(']]&gt;')
  }

  let endIndex = context.source.length
  for (let i = 0; i &lt; endTokens.length; i++) {
    const index = context.source.indexOf(endTokens[i], 1)
    if (index !== -1 &amp;&amp; endIndex &gt; index) {
      endIndex = index
    }
  }

  __TEST__ &amp;&amp; assert(endIndex &gt; 0)

  const start = getCursor(context)
  const content = parseTextData(context, endIndex, mode)

  return {
    type: NodeTypes.TEXT,
    content,
    loc: getSelection(context, start)
  }
}
function parseTextData(
  context: ParserContext,
  length: number,
  mode: TextModes
): string {
  const rawText = context.source.slice(0, length)
  advanceBy(context, length)
  if (
    mode === TextModes.RAWTEXT ||
    mode === TextModes.CDATA ||
    rawText.indexOf('&amp;') === -1
  ) {
    return rawText
  } else {
    // DATA or RCDATA containing &quot;&amp;&quot;&quot;. Entity decoding required.
    return context.options.decodeEntities(
      rawText,
      mode === TextModes.ATTRIBUTE_VALUE
    )
  }
}
</code></pre></div><p>回到上面的判断，对于 <code>mode === TextModes.DATA || mode === TextModes.RCDATA</code> 模式下，记住根节点是 TextModes.DATA 模式，继续判断，如果不在 inVPre 下面，又是左 delimiters 开头的，对于默认 delimiters 对是 <code>{{</code> 和 <code>}}</code>，这些都满足，则进行插值 parseInterpolation 的解析。</p> <div class="language- extra-class"><pre class="language-text"><code>if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
    if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) {
        // '{{'
        node = parseInterpolation(context, mode)
      } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') {
       
    }
}
</code></pre></div><p>parseInterpolation 插值函数如下，拿到界定符，判断有没有结束界定符，没有的话，抛出错误，返回 undefined ，这样后续可以被上面解读的 parseText 进行处理。start 是插值符的开始位置， innerStart 是 插值内容开始的位置，这个会被进行二次修复，因为内容前面可能会有空格，同样 innerEnd 是指插值内容结束的位置，也会被二次修复，但是为什么 <code>const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset)</code> 这样算呢？</p> <p>首先 rawContentLength 是原始插值的长度，里面可能包含前后空格以及内容可能需要解码，如果需要解码，解码后的内容是比没有解码前的内容长度要短的，<code>(preTrimContent.length - content.length - startOffset)</code> 拿到的是内容后面空格的长度，所以 endOffset 就是原始插值减去后面空格的长度，修复 innerEnd 之后，继续把 context 推向前 close 的长度，最后返回节点类型为 NodeTypes.INTERPOLATION，content 为 NodeTypes.SIMPLE_EXPRESSION 类型，其中 isConstant 会在 transformExpression 真正确定下来，这里默认为 false。</p> <div class="language- extra-class"><pre class="language-text"><code>function parseInterpolation(
  context: ParserContext,
  mode: TextModes
): InterpolationNode | undefined {
  const [open, close] = context.options.delimiters
  __TEST__ &amp;&amp; assert(startsWith(context.source, open))

  const closeIndex = context.source.indexOf(close, open.length)
  if (closeIndex === -1) {
    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)
    return undefined
  }

  const start = getCursor(context)
  advanceBy(context, open.length)
  const innerStart = getCursor(context)
  const innerEnd = getCursor(context)
  const rawContentLength = closeIndex - open.length
  const rawContent = context.source.slice(0, rawContentLength)
  const preTrimContent = parseTextData(context, rawContentLength, mode)
  const content = preTrimContent.trim()
  const startOffset = preTrimContent.indexOf(content)
  if (startOffset &gt; 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset)
  }
  const  =
    rawContentLength - (preTrimContent.length - content.length - startOffset)
  advancePositionWithMutation(innerEnd, rawContent, endOffset)
  advanceBy(context, close.length)

  return {
    type: NodeTypes.INTERPOLATION,
    content: {
      type: NodeTypes.SIMPLE_EXPRESSION,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      isConstant: false,
      content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  }
}
</code></pre></div><p>回到循环，如果不是插值，看看是不是处于 TextModes.DATA 模式，以及第一个字符串是不是 '&lt;'，需要注意的一点是，只要没有自定义的 onError 不是抛出错误的话，最后的都会被 parseText 兜底处理的。</p> <p>下面继续看，如果  <code>s.length === 1</code> 则 上报错误，否则如果看看字符串第二位是不是 <code>!</code>，因为有可能是 html 注解<code>&lt;!--</code>， 也有可能是 DOCTYPE <code>&lt;!DOCTYPE</code>,  如果是 <code>&lt;![CDATA[</code> 开头且 不是出于 Namespaces.HTML 命名空间下的话，则用 parseCDATA 解析，否则上报 <code>CDATA_IN_HTML_CONTENT</code> 错误，如果 <code>!</code> 都没有被处理的话，上报 <code>INCORRECTLY_OPENED_COMMENT</code> 错误，上面两个错误都用 parseBogusComment 兜底处理 如果上报没有抛出错误的话。</p> <div class="language- extra-class"><pre class="language-text"><code>else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') {
    // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
    if (s.length === 1) {
      emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)
    } else if (s[1] === '!') {
      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
      if (startsWith(s, '&lt;!--')) {
        node = parseComment(context)
      } else if (startsWith(s, '&lt;!DOCTYPE')) {
        // Ignore DOCTYPE by a limitation.
        node = parseBogusComment(context)
      } else if (startsWith(s, '&lt;![CDATA[')) {
        if (ns !== Namespaces.HTML) {
          node = parseCDATA(context, ancestors)
        } else {
          emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)
          node = parseBogusComment(context)
        }
      } else {
        emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)
        node = parseBogusComment(context)
      }
    } else if (s[1] === '/') {
        ...
    } else if (/[a-z]/i.test(s[1])) {
      ...
    } else if (s[1] === '?') {
     ...
    } else {
     ...
    }
}
</code></pre></div><p>接下来，先讲讲 <code>!</code> 开头用到的几个解析函数，parseComment 、parseBogusComment 和 parseCDATA。</p> <p>先看看 parseComment， 先断言是否符合注释，接着用正则匹配注释的结尾，如果匹配不到，则消费完剩下的source，同时上报 <code>EOF_IN_COMMENT</code> 错误。如果 <code>match.index &lt;= 3</code>, 说明匹配到的 <code>--</code> 是注释开头的 <code>--</code>, 上报<code>ABRUPT_CLOSING_OF_EMPTY_COMMENT</code>,如果分组1有有值，上报 <code>INCORRECTLY_CLOSED_COMMENT</code>,注释结尾不允许有感叹号。接着判断注释里面有没有嵌套注释，有的话，也要上报 <code>NESTED_COMMENT</code>，至于<code>advanceBy(context, nestedIndex - prevIndex + 1)</code> 为什么要加1呢，因为 prevIndex 是 context 中位置的下一个位置，所以需要在修复正确的长度要加1。最后返回 type 为 NodeTypes.COMMENT， content 为注释内容的 AST 节点。</p> <div class="language- extra-class"><pre class="language-text"><code>function parseComment(context: ParserContext): CommentNode {
  __TEST__ &amp;&amp; assert(startsWith(context.source, '&lt;!--'))

  const start = getCursor(context)
  let content: string

  // Regular comment.
  const match = /--(\!)?&gt;/.exec(context.source)
  if (!match) {
    content = context.source.slice(4)
    advanceBy(context, context.source.length)
    emitError(context, ErrorCodes.EOF_IN_COMMENT)
  } else {
    if (match.index &lt;= 3) {
      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)
    }
    if (match[1]) {
      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)
    }
    content = context.source.slice(4, match.index)

    // Advancing with reporting nested comments.
    const s = context.source.slice(0, match.index)
    let prevIndex = 1,
      nestedIndex = 0
    while ((nestedIndex = s.indexOf('&lt;!--', prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1)
      if (nestedIndex + 4 &lt; s.length) {
        emitError(context, ErrorCodes.NESTED_COMMENT)
      }
      prevIndex = nestedIndex + 1
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1)
  }

  return {
    type: NodeTypes.COMMENT,
    content,
    loc: getSelection(context, start)
  }
}
</code></pre></div><p>再看看 parseBogusComment，也是一开始用正则去判断开头是否符合，这个正则有点意思，就是开头<code>&lt;</code>, 中间或者是 <code>!</code> 或者 <code>?</code> 或者是 <code>/</code> 后面跟着不是 a 到 z。</p> <div class="language- extra-class"><pre class="language-text"><code>function parseBogusComment(context: ParserContext): CommentNode | undefined {
  __TEST__ &amp;&amp; assert(/^&lt;(?:[\!\?]|\/[^a-z&gt;])/i.test(context.source))

  const start = getCursor(context)
  const contentStart = context.source[1] === '?' ? 1 : 2
  let content: string

  const closeIndex = context.source.indexOf('&gt;')
  if (closeIndex === -1) {
    content = context.source.slice(contentStart)
    advanceBy(context, context.source.length)
  } else {
    content = context.source.slice(contentStart, closeIndex)
    advanceBy(context, closeIndex + 1)
  }

  return {
    type: NodeTypes.COMMENT,
    content,
    loc: getSelection(context, start)
  }
}
</code></pre></div><p>我们可以循环那里看看 bogusComment 的适用范围。DOCTYPE 、CDATA 在 Namespaces.HTML 命名空间时、<code>&lt;！</code>开头的兜底、s[1] 为 <code>/</code> 且 s[2] 不为 <code>[a-z]</code>, <code>&lt;?</code>开头的。这么一解释，是不是上面的正则就好理解了。</p> <div class="language- extra-class"><pre class="language-text"><code>else if (s[1] === '!') {
  // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
  if (startsWith(s, '&lt;!--')) {
    node = parseComment(context)
  } else if (startsWith(s, '&lt;!DOCTYPE')) {
    // Ignore DOCTYPE by a limitation.
    node = parseBogusComment(context)
  } else if (startsWith(s, '&lt;![CDATA[')) {
    if (ns !== Namespaces.HTML) {
      node = parseCDATA(context, ancestors)
    } else {
      emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)
      node = parseBogusComment(context)
    }
  } else {
    emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)
    node = parseBogusComment(context)
  }
} else if (s[1] === '/') {
  // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
  if (s.length === 2) {
    emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)
  } else if (s[2] === '&gt;') {
    emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)
    advanceBy(context, 3)
    continue
  } else if (/[a-z]/i.test(s[2])) {
    emitError(context, ErrorCodes.X_INVALID_END_TAG)
    parseTag(context, TagType.End, parent)
    continue
  } else {
    emitError(
      context,
      ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,
      2
    )
    node = parseBogusComment(context)
  }
} else if (/[a-z]/i.test(s[1])) {
  node = parseElement(context, ancestors)
} else if (s[1] === '?') {
  emitError(
    context,
    ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,
    1
  )
  node = parseBogusComment(context)
} else {
  emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)
}
</code></pre></div><p>那我们回到 parseBogusComment 继续讲解。对于 <code>context.source[1] === '?'</code> 为 true， 注释的内容包含 <code>?</code>，否则不包含。然后寻找结束标签<code>&gt;</code>，找不到消费全部的 source。对于 closeIndex + 1, 因为这才是整个注释的长度。</p> <p>接下来讲解 parseCDATA。一开始也是两个断言，祖先不能为空，祖先的命名空间不能是 Namespaces.HTML，然后也是要求 <code>&lt;![CDATA[</code> 开头的。接着往前推进 context，在里面嵌套调用 parseChildren， 需要注意的是，这是的 <code>ancestors</code> 没有元素进栈，也就是没有改变命名空间，第二是解析模式是 <code>TextModes.CDATA</code>，这意味着这个嵌套 parseChildren 里面只是调用 parseText 去解析节点。同时返回来的内容可能包含多个节点，这也是 parseChildren 的循环里面需要判断返回的节点是否是数组的原因了。</p> <div class="language- extra-class"><pre class="language-text"><code>function parseCDATA(
  context: ParserContext,
  ancestors: ElementNode[]
): TemplateChildNode[] {
  __TEST__ &amp;&amp;
    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)
  __TEST__ &amp;&amp; assert(startsWith(context.source, '&lt;![CDATA['))

  advanceBy(context, 9)
  const nodes = parseChildren(context, TextModes.CDATA, ancestors)
  if (context.source.length === 0) {
    emitError(context, ErrorCodes.EOF_IN_CDATA)
  } else {
    __TEST__ &amp;&amp; assert(startsWith(context.source, ']]&gt;'))
    advanceBy(context, 3)
  }

  return nodes
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/slamdunk-the-vue3/main/vue/compiler/compiler.html" class="prev">
        compiler
      </a></span> <span class="next"><a href="/slamdunk-the-vue3/main/vue/compiler/transform.html">
        transform
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/slamdunk-the-vue3/assets/js/app.97c78449.js" defer></script><script src="/slamdunk-the-vue3/assets/js/2.ff58ff2a.js" defer></script><script src="/slamdunk-the-vue3/assets/js/12.65c8523a.js" defer></script>
  </body>
</html>
